/*
 * cryptpe -- Encryption tool for PE binaries
 * (C) 2012 Martin Wolters
 *
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>

#include "..\shared\types.h"
#include "..\shared\rc4.h"

#include "huffman_enc.h"

void getrandom(uchar *dst, int len) {
	HCRYPTPROV provider;
	
	CryptAcquireContext(&provider, NULL, NULL, PROV_RSA_FULL, 0);
	CryptGenRandom(provider, len, dst);
	CryptReleaseContext(provider, 0);	
}

void printtable(char *name, uchar *bin, size_t len, rc4_ctx_t *ctx) {
	size_t i;
	uchar rc4_buf[320];

	printf("uchar %s[] = {", name);
	for(i = 0; i < len; i++) {
		if(!(i % 32))
			printf("\n\t");
		if(ctx && !(i % 320))
			rc4_gen(rc4_buf, 320, ctx);

		printf("0x%02x", bin[i] ^ (ctx? rc4_buf[i % 320] : 0));
		if(i < (len - 1))
			printf(", ");
	}
	printf("\n};\n\n");	
}

int main(int argc, char **argv) {
	rc4_ctx_t rc4_ctx;
	uchar rc4_key[RC4_KEY_SIZE], *file_buf, *enc_tree, *encoded;
	size_t pos = 0, file_size, tree_size;
	hfm_node_t *root;
	hfm_cdb_t *codebook;
	FILE *fp;

	if(argc == 1) {
		fprintf(stderr, "USAGE: %s <FILENAME>\n", argv[0]);
		return EXIT_FAILURE;
	}

	if((fp = fopen(argv[1], "rb")) == NULL) {
		fprintf(stderr, "ERROR: Could not open '%s'.\n", argv[1]);
		return EXIT_FAILURE;
	}
	
	printf("/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY MKBINTABLE */\n\n");
	printf("#include \"..\\shared\\types.h\"\n\n#ifndef BINTABLE_H_\n#define BINTABLE_H_\n\n");

	fseek(fp, 0, SEEK_END);
	file_size = ftell(fp);
	file_buf = malloc(file_size);
	fseek(fp, 0, SEEK_SET);
	fread(file_buf, file_size, 1, fp);
	printf("size_t file_size = %d;\n\n", file_size);

	getrandom(rc4_key, RC4_KEY_SIZE);
	rc4_ctx = rc4_init(rc4_key, RC4_KEY_SIZE);
	rc4_drop(3072, &rc4_ctx);
	printtable("rc4_key", rc4_key, RC4_KEY_SIZE, NULL);

	root = maketree(file_buf, file_size);
	enc_tree = encode_tree(root, &tree_size);
	printtable("tree", enc_tree, tree_size, &rc4_ctx);

	codebook = make_codebook(root);
	encoded = encode(file_buf, file_size, codebook, &file_size);
	printtable("binary", encoded, file_size, &rc4_ctx);
	printf("#endif\n");

	free(codebook);
	free(enc_tree);
	free(file_buf);
	free_tree(root);
	fclose(fp);

	return EXIT_SUCCESS;
} 
